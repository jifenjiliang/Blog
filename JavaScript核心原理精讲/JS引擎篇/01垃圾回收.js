/*
 * @Description: 垃圾回收：释放内存，提升浏览器页面性能
 * @Autor: lijinpeng
 * @Date: 2021-03-08 23:07:07
 * @LastEditors: lijinpeng
 */
// JavaScript 的内存管理
// 分为这三个步骤：
// 1.分配你所需要的系统内存空间；
// 2.使用分配到的内存进行读或者写等操作；
// 3.不需要使用内存时，将其空间释放或者归还。

// 与其他需要手动管理内存的语言不太一样的地方是，在 JavaScript 中，当我们创建变量（对象，字符串等）的时候，
// 系统会自动给对象分配对应的内存。
var a = 123; // 给数值变量分配栈内存
var etf = "ARK"; // 给字符串分配栈内存
// 给对象及其包含的值分配堆内存
var obj = {
  name: 'tom',
  age: 13
};
// 给数组及其包含的值分配内存（就像对象一样）
var a = [1, null, "PSAC"];
// 给函数（可调用的对象）分配内存
function sum(a, b){
  return a + b;
}

// 当系统经过一段时间发现这些变量不会再被使用的时候，会通过垃圾回收机制的方式来处理掉这些变量所占用的内存，
// 其实开发者不用过多关心内存问题。
// 栈内存中的基本类型，可以通过操作系统直接处理；
// 而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。

// Chrome 内存回收机制
// 在 Chrome 浏览器中，JavaScript 的 V8 引擎被限制了内存的使用，
// 根据不同的操作系统（操作系统有 64 位和 32 位的）内存大小会不同，大的可以到 1.4G 的空间，小的只能到 0.7G 的空间。
// V8 最开始是为浏览器而设计的引擎，早些年由于 Web 应用都比较简单，其实并未考虑占据过多的内存空间；
// 另外又由于被 V8 的垃圾回收机制所限制，比如清理大量的内存时会耗费很多时间，
// 这样会引起 JavaScript 执行的线程被挂起，会影响当前执行的页面应用的性能。
// Chrome 的 JavaScript 引擎 V8 将堆内存分为两类 新生代的回收机制和老生代的回收机制

// 新生代内存回收
// 左边部分表示正在使用的内存空间，右边是目前闲置的内存空间。当浏览器开始进行内存的垃圾回收时，
// JavaScript 的 V8 引擎会将左边的对象检查一遍。如果引擎检测是存活对象，那么会复制到右边的内存空间去；
// 如果不是存活的对象，则直接进行系统回收。当所有左边的内存里的对象没有了的时候，
// 等再有新生代的对象产生时，上面的部分左右对调，这样来循环处理。
// 当堆内存分配存在零散情况的时候 也就是产生内存碎片 这是就需要使用 Scavenge 去处理 使堆内存是连续分配的

// 老生代内存回收
// 新生代中的变量如果经过回收之后依然一直存在，那么就会被放入到老生代内存中
// 只要是已经经历过一次 Scavenge 算法回收的，就可以晋升为老生代内存的对象。
// 那么在进入老生代的内存回收机制中，就不能再用 Scavenge 的算法了
// 采用了 Mark-Sweep（标记清除） 和 Mark-Compact（标记整理）的策略

// 标记清除（Mark-Sweep）
// 标记清除分为两个阶段：标记阶段和清除阶段
// 首先它会遍历堆上的所有的对象，分别对它们打上标记；然后在代码执行过程结束之后，对使用过的变量取消标记。
// 那么没取消标记的就是没有使用过的变量，因此在清除阶段，就会把还有标记的进行整体清除，从而释放内存空间。

// 标记整理（Mark-Compact）
// 经过标记清除策略调整之后，老生代的内存中因此产生了很多内存碎片
// 标记整理添加了活动对象整理阶段，处理过程中会将所有的活动对象往一端靠拢，整体移动完成后，直接清理掉边界外的内存

// 内存泄漏与优化
// 内存泄漏是指 JavaScript 中，已经分配堆内存地址的对象由于长时间未释放或者无法释放，
// 造成了长期占用内存，使内存浪费，最终会导致运行的应用响应速度变慢以及最终崩溃的情况
// 过多的缓存未释放；
// 闭包太多未释放；
// 定时器或者回调太多未释放；
// 太多无效的 DOM 未释放；
// 全局变量太多未被发现。

// 解决方法
// 1. 减少不必要的全局变量，使用严格模式避免意外创建全局变量
// 2. 在你使用完数据后，及时解除引用（闭包中的变量，DOM 引用，定时器清除）
// 3. 组织好你的代码逻辑，避免死循环等造成浏览器卡顿、崩溃的问题
// 最好的解决方式是通过熟练使用 Chrome 的内存剖析工具，多分析多定位 Chrome 帮你分析保留的内存快照，
// 来查看持续占用大量内存的对象。最好在业务代码上线前做好分析和诊断，之后才能保证线上业务的质量。